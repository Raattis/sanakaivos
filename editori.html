	<!DOCTYPE html>
<html lang="fi">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Kaivos editori</title>
	<script src="sanat.js"></script>
	<link rel="stylesheet" href="style.css">
	<style>
		.filter-list-container {
			width: 250px;
			height: 480px;
		}
		input[type="text"] {
			padding: 5px;
			border: none;
			border-radius: 5px;
			background-color: #333;
			color: #ffffff;
		}
		ul {
			list-style-type: none;
			padding: 0;
			width: min(200px, 80vw);
			margin: auto;
			padding: 10px;
		}
		li {
			padding: 0px;
			background-color: #1e1e1e;
			margin: 2px 0;
			border-radius: 5px;
			cursor: pointer;
		}
	</style>
</head>
<body>
	<div class="page-center">
		<div class="column">
			<h1>Kaivos editori</h1>
			<div id="sana-container" style="position:relative;height:25px">
				<div id="sana" class="viesti"></div>
				<div id="virhe" class="viesti"></div>
			</div>
			<div id="board-container">
				<div id="board" class="board"></div>
			</div>
			<div id="loydetyt_sanat" class="sana_list"></div>
			<div id="kopioi-tulos" class="button-container"><button id="copyToClipboard" class='button'>Kopioi linkki</button></div>
			<!--div id="koodi" class="button"></div-->
		</div>
		<div class="column">
			<div class="filter-list-container">
				<div>
					<input type="text" id="searchInput" placeholder="Type to filter words..." />
					<button id="shuffle" onclick="enableShuffle = !enableShuffle; displayWords()">Shuffle</button>
				</div>
				<ul id="filter-list"></ul>
			</div>
		</div>

	</div>
	<script>
		let enableShuffle = false;
		const searchInput = document.getElementById('searchInput');
		let scrollAmount = 0;
		const filterListElements = [];
		function displayWords() {
			while (filterListElements.length < 20) {
				const li = document.createElement('li');
				document.getElementById('filter-list').appendChild(li);
				filterListElements.push(li)
				li.addEventListener('click', () => {
					addWord(li.dataset.word, -1);
				});
			}

			const query = searchInput.value.toUpperCase();
			const spentLetters = countTotalLetters();
			const maxLength = spentLetters <= 27 ? 30 - spentLetters : 10;
			const filteredWords = validWords.filter(word => word.includes(query) && word.length <= maxLength);
			if (enableShuffle) {
				scrollAmount = 0;
				shuffle.textContent = "Sort";
				for (let i = filteredWords.length; i-- > 0;) {
					let j = Math.random() * (i + 1) | 0;
					[filteredWords[i], filteredWords[j]] = [filteredWords[j], filteredWords[i]];
				}
			} else {
				shuffle.textContent = "Shuffle";
			}
			if (scrollAmount < 0) {
				scrollAmount = 0;
			}
			const leaveVisible = Math.floor(filteredWords.length * 0.5);
			if (scrollAmount + leaveVisible > filteredWords.length) {
				scrollAmount = filteredWords.length - leaveVisible - 1;
			}
			//console.log(scrollAmount);
			for (let ii = 0; ii < filterListElements.length; ii++) {
				const i = Math.floor(ii + scrollAmount);
				//console.log(`${ii}/${filterListElements.length} -> ${i}/${filteredWords.length}`);
				const li = filterListElements[ii];
				if (i >= filteredWords.length) {
					li.classList.add("hide");
					li.dataset.word = ""
					continue;
				}
				li.classList.remove("hide");
				li.textContent = "[" + filteredWords[i].length + "] " + filteredWords[i];
				li.dataset.word = filteredWords[i];
			}
		}

		const filterList = document.getElementById('filter-list');
		filterList.addEventListener('wheel', (event) => {
			scrollAmount += event.deltaY * 0.2;
			displayWords();
		});

		{ // Touch scrolling
			let startY = 0;
			let initialScrollAmount = 0;
			filterList.addEventListener('touchstart', (e) => {
				startY = e.touches[0].clientY;
				initialScrollAmount = scrollAmount;
			});

			filterList.addEventListener('touchmove', (e) => {
				const y = e.touches[0].clientY;
				scrollAmount = initialScrollAmount + Math.floor((startY - y) / 10);
				displayWords();
				e.preventDefault();
			}, { passive: false });
		}

		searchInput.addEventListener('input', displayWords);

		const copyButton = document.getElementById('copyToClipboard');
		copyButton.addEventListener('click', ()=>{
			if (countSelectedLetters() != 30) {
				clearSelected();
				updateCurrentWord();
				return;
			}


			const domain = window.location.href.split('/editori.html')[0];
			const shareableUrl = domain + "/index.html?" + generateLevelCode();
			let msg = "Tein uuden sanakaivoksen! Pääsetkö sen läpi?\n" + shareableUrl;
			//console.log("Copied to clipboard: " + msg);
			navigator.clipboard.writeText(msg);
			copyButton.textContent = "Kopioitu!";
		});

		const obfuscationKey = "jy2d7ukxpX1Dz04YgFaK8ChHwOW9qlr";
		function encodeLevelCode(letters, intendedWords) {
			function encode(c) {
				c = +c;
				if (c < 0 || obfuscationKey.length <= c) {
					const msg = "ERROR: Encode failed = " + c
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				}
				return obfuscationKey[c];
			}
			let levelCode = "";
			for (let i = 0; i < intendedWords.length; i += 1) {
				if (i != 0)
					levelCode += encode(obfuscationKey.length - 1);
				for (let j = 0; j < intendedWords[i].length; j += 1) {
					levelCode += encode(intendedWords[i][j]);
				}
			}
			levelCode.length -= 1;
			const a = +('A'.charCodeAt(0));
			for (let i = 0; i < letters.length; i += 1) {
				let charCode = letters[i].charCodeAt(0) - a;
				if (charCode < 0 || charCode >= 26) {
					if (letters[i] == 'Å')
						charCode = 26;
					if (letters[i] == 'Ä')
						charCode = 27;
					if (letters[i] == 'Ö')
						charCode = 28;
				}
				levelCode += encode(charCode);
			}
			return levelCode;
		}

		function decodeLevelCode(levelCode, letters, intendedWords) {
			function decode(c) {
				if (!obfuscationKey.includes(c)) {
					const msg = "ERROR: Decode failed = " + c
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				}
				return obfuscationKey.indexOf(c);
			}

			letters.splice(0, letters.length);
			intendedWords.splice(0, intendedWords.length);
			intendedWords.push([]);
			let intendedLetterCount = 0;
			let i = 0;
			const mayContainIntendedWords = levelCode.length >= 62 && levelCode.includes(obfuscationKey[obfuscationKey.length - 1]);
			for (; intendedLetterCount < 30 && i < levelCode.length && mayContainIntendedWords; ++i) {
				const c = decode(levelCode[+i]);
				if (c == obfuscationKey.length - 1) {
					intendedWords.push([]);
					continue;
				}
				if (intendedWords[intendedWords.length - 1].length >= 10) {
					console.log("Intended word is too long. Assuming the url only has the letters.");
					i = 0;
					intendedWords.splice(0, intendedWords.length);
					break;
				}
				intendedWords[intendedWords.length - 1].push(c);
				intendedLetterCount += 1;
			}
			const a = +('A'.charCodeAt(0));
			for (; letters.length < 30 && i < levelCode.length; ++i) {
				const charCode = decode(levelCode[+i]);
				let str = undefined;
				if (charCode == 26)
					str = 'Å';
				else if (charCode == 27)
					str = 'Ä';
				else if (charCode == 28)
					str = 'Ö';
				else
					str = String.fromCharCode(a + charCode)
				letters.push(str);
			}
		}

		const letters = [];
		let originalUrl = "";
		const originalFoundWords = [];
		const originalWordList = [];
		{
			let givenLevelCode = "ykjuD1gYrCO8Wh9rqlwKHFza4rd2x0X7p744FKDzapKK7K7jpKFjkpYz70Fpj1j";
			const url = window.location.href.split('?');
			originalUrl = url[0];
			if (url.length == 2) {
				givenLevelCode = url[1];
			}

			const sanatPrefix = 'sanat=';
			if (givenLevelCode.startsWith(sanatPrefix)) {
				givenLevelCode = givenLevelCode.replaceAll("%C3%85","Å").replaceAll("%C3%84","Ä").replaceAll("%C3%96","Ö");
				let args = givenLevelCode.substring(sanatPrefix.length).split('&');
				let wordsStr = args[0];
				wordsStr.split(',').filter(w => w.length >= 3).forEach(w => originalWordList.push(w));
				//console.log(originalWordList);

				const kirjaimetPrefix = 'kirjaimet=';
				if (args.length > 1 && args[1].startsWith(kirjaimetPrefix)) {
					args[1].substring(kirjaimetPrefix.length).split('').forEach(c => letters.push(c));
				}
				while (letters.length < 30) {
					if (wordsStr.length > 0) {
						const c = wordsStr[0].toUpperCase();
						//console.log(c)
						wordsStr = wordsStr.substring(1);
						if (c !== ',')
							letters.push(c)
					} else {
						letters.push('A')
					}
				}

				const paikatPrefix = 'paikat=';
				if (args.length > 2 && args[2].startsWith(paikatPrefix)) {
					const paikat = [];
					args[2].substring(paikatPrefix.length).split(',').forEach(p => paikat.push(+p));
					let i = 0;
					let wl_index = 0;
					while (wl_index < originalWordList.length) {
						const w = originalWordList[wl_index];
						wl_index++;
						if (i >= paikat.length)
							break;
						const ow = [];
						for (const _ of w) {
							if (i >= paikat.length)
								break;
							ow.push(paikat[i]);
							i++;
						}
						if (ow.length > 0 && ow[0] != -1) {
							wl_index--;
							originalWordList.splice(wl_index, 1);
							originalFoundWords.push(ow);
						}
					}
				}
			} else {
				decodeLevelCode(givenLevelCode, letters, originalFoundWords);
				let intendedLetterCount = 0;
				originalFoundWords.forEach(arr => intendedLetterCount += arr.length);
				if (intendedLetterCount == 0) {
					const msg = "Mallivastaus puuttuu. Kaivos voi olla mahdoton.";
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				} else if (intendedLetterCount != letters.length) {
					const msg = "Mallivastauksessa väärä määrä kirjaimia: " + intendedLetterCount + ", kun pitäsi olla " + letters.length + ".";
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				}
			}
		}

		function makeCells(resultCells, parentElement, interactive) {
			letters.forEach((letter, index) => {
				const cellWrapper = document.createElement('div');
				cellWrapper.classList.add('cell-wrapper');
				parentElement.appendChild(cellWrapper);

				const cell = document.createElement('div');
				cellWrapper.appendChild(cell);

				cell.textContent = letter;
				cell.classList.add('cell');
				cell.classList.add('intended');
				cell.dataset.index = index;
				cell.dataset.letter = letter;
				resultCells.push(cell);
				if (!interactive) {
					cellWrapper.classList.add('non-interactive');
					return;
				}

				cellWrapper.addEventListener('click', () => {
					const selectedIndex = selectedCells.indexOf(cell);
					if (selectedIndex > -1 && selectedIndex + 1 == selectedCells.length) {
						toggleSelection(cell);
						return;
					}
					if (selectedIndex > -1) {
						//clearSelected()
						return;
					}

					for (i in foundWords) {
						if (foundWords[i].includes(cell)) {
							removeWord(foundWords[i]);
							return;
						}
					}

					for (word in foundWords)
					{
						if (!word.includes(cell)) continue;
						removeWord(word);
						return;
					}

					if (isAdjacent(cell)) {
						toggleSelection(cell);
					}
				});
			});
		}

		const allCells = [];
		const selectedCells = [];
		const foundWords = [];
		const wordListing = [];
		const connectors = [];

		displayWords();
		makeCells(allCells, document.getElementById('board'), true);

		originalWordList.forEach(str => {
			addWord(str, -1);
		});

		originalFoundWords.forEach(wi => {
			const w = [];
			let str = "";
			let prevCell = null;
			wi.forEach(i => {
				const cell = allCells[i];
				w.push(cell);
				cell.classList.add("used");
				if (prevCell) {
					connect(prevCell, cell, "used");
				}
				str += cell.dataset.letter;
				prevCell = cell;
			});

			if (!validWords.includes(str))
				console.log('invalid word ' + str);
			foundWords.push(w);
			addWord(str, wi[0]);
		});

		function disconnect(cell1, cell2) {
				if (!cell1 || !cell2) return;

				const rect1 = cell1.dataset.index < cell2.dataset.index ? cell1 : cell2;
				const rect2 = cell1.dataset.index < cell2.dataset.index ? cell2 : cell1;
				const key = rect1.dataset.index + "-" + rect2.dataset.index;
				//console.log(`trying to disconnect(${cell1.dataset.index}, ${cell2.dataset.index}) -> ${key} & ${rect1.dataset.index}`);
				const line = connectors.find(l => l.dataset.key === key);
				//console.log(`found ${line}`);
				if (line) {
					let index = connectors.indexOf(line);
					//console.log(line, index, connectors);
					//console.log(`disconnect(${cell1.dataset.index}, ${cell2.dataset.index}) -> ${key} & ${rect1.dataset.index}`);
					connectors.splice(index, 1);
					line.remove();
				}
		};

		function connect(cell1, cell2, style) {
			connectImpl(document.getElementById('board-container'), cell1, cell2, style);
		}

		function connectImpl(containter, cell1, cell2, style) {
				disconnect(cell1, cell2);
				const line = document.createElement('div');
				containter.appendChild(line);
				line.classList.add('line');
				line.classList.add(style);
				const rect1 = cell1.dataset.index < cell2.dataset.index ? cell1 : cell2;
				const rect2 = cell1.dataset.index < cell2.dataset.index ? cell2 : cell1;
				const key = rect1.dataset.index + "-" + rect2.dataset.index;
				line.dataset.key = key;

				const x1 = rect1.offsetLeft + rect1.offsetWidth * 0.5;
				const y1 = rect1.offsetTop + rect1.offsetHeight * 0.5;
				const x2 = rect2.offsetLeft + rect2.offsetWidth * 0.5;
				const y2 = rect2.offsetTop + rect2.offsetHeight * 0.5;
				const diagonality = (x1 != x2 && y1 != y2) ? Math.pow(2, 0.5) : 1.0;
				const w = 45 * diagonality;
				const h = 10;
				const ox = x1 == x2 ? 0 : x1 < x2 ? 0 : -0;
				const oy = y1 == y2 ? 0 : y1 < y2 ? 0 : -0;
				const cx = (x1 + x2) * 0.5;
				const cy = (y1 + y2) * 0.5;
				const angle = Math.atan2(y2 - y1, x2 - x1);
				line.style.position = 'absolute';
				line.style.top = `${cy + oy - h*0.5}px`;
				line.style.left = `${cx + ox - w*0.5}px`;
				line.style.transform = `rotate(${angle}rad)`;
				line.style.width = `${w}px`;
				line.style.zIndex = -1;
				//console.log(rect1, rect2, line)
				connectors.push(line);
				return line;
		};

		function generateLevelCode() {
			const tempLetters =	[];
			const words = [];
			for (let i = 0; i < allCells.length; ++i) {
				tempLetters.push(allCells[i].dataset.letter);
			}
			//console.log(tempLetters);
			foundWords.forEach(word => {
				const result = [];
				word.forEach(l => result.push(l.dataset.index));
				words.push(result);
			});
			const generatedLevelCode = encodeLevelCode(tempLetters, words);
			return generatedLevelCode;
		}

		function generateWipLevelCode() {
			const sanat = [];
			const paikat = [];
			for (const wl of wordListing) {
				sanat.push(wl.textContent);
				if (wl.dataset.owner != -1) {
					const fw = foundWords.find(w => w[0].dataset.index === wl.dataset.owner);
					if (fw) {
						fw.forEach(cell => paikat.push(+cell.dataset.index));
						continue;
					}
				}
				for (let i = 0; i < wl.textContent.length; ++i) {
					paikat.push(-1);
				}
			}

			if (sanat.length === 0)
				return "sanat=";

			let result = "";
			result += "sanat=" + sanat.join(',');
			result += "&kirjaimet=" + letters.join('');
			result += "&paikat=" + paikat.join(',');
			//console.log(result);
			return result;
		}

		function countSelectedLetters() {
			let foundCount = 0;
			foundWords.forEach(word => foundCount += word.length);
			return foundCount;
		}

		function removeWord(word) {
			word.forEach((cell) => { cell.classList.remove('used'); });
			for (i in word)
			{
				if (+i + 1 < word.length)
					disconnect(word[i], word[+i + 1]);
			}

			const index = foundWords.indexOf(word);
			for (const wl of wordListing.filter(w=>+w.dataset.owner === foundWords[index][0].dataset.index)) {
				//console.log("removing owner from:", wl);
				wl.dataset.owner = -1;
			}
			foundWords.splice(index, 1);
			updateCurrentWord();
			displayWords();
		}

		function addWord(word, firstCellIndex) {
			if (!validWords.includes(word)) {
				console.log('invalid word ' + word);
				document.getElementById('virhe').textContent = `${word} ei ole oikea sana`;
				updateCurrentError();
			}

			const wlist = document.createElement('div');
			wordListing.push(wlist);
			wlist.textContent = word;
			wlist.dataset.owner = firstCellIndex;
			wlist.classList.add("loydetty_sana");
			document.getElementById('loydetyt_sanat').appendChild(wlist);
			wlist.addEventListener('click', () => {
				let wasFound = false;
				for (let i = foundWords.length; i-- > 0; ) {
					if (foundWords[i][0].dataset.index == wlist.dataset.owner) {
						removeWord(foundWords[i]);
						wasFound = true;
						//console.log("found");
					}
				}
				if (wasFound) return;

				const i = wordListing.indexOf(wlist);
				wordListing.splice(i, 1)[0].remove();
				updateCurrentWord();
			});
			if (validWords.includes(word))
				updateCurrentWord();
			displayWords();
		}

		function clearSelected() {
			selectedCells.forEach((cell) => {
				//console.log(`clearing: ${cell.dataset.index}`);
				cell.classList.remove('selected');
			});
			//console.log(selectedCells.length, selectedCells);
			for (i in selectedCells)
			{
				//console.log(i, selectedCells);
				if (+i + 1 < selectedCells.length)
					disconnect(selectedCells[i], selectedCells[+i + 1]);
			}
			selectedCells.length = 0;
		}

		function popSelection() {
			//console.log("pop!")
			const index = selectedCells.length - 1;
			if (index <= -1)
			{
				//console.log("Trying to unselect non-selected cell.");
				return;
			}

			const cell = selectedCells.splice(index, 1)[0];
			cell.classList.remove('selected');
			if (index > 0)
				disconnect(selectedCells[index - 1], cell);
		}

		function toggleSelection(cell) {
			const index = selectedCells.indexOf(cell);
			if (index > -1 && selectedCells.length == index + 1) {
				if (selectedCells.length == 1) { clearSelected(); }
				else { popSelection(); }
				updateCurrentWord();
				return;
			} else {
				const nextLetter = getNextLetter();
				if (nextLetter === undefined) {
					//console.log("No more letters to place.");
					currentListing = -1;
					return;
				}
				if (selectedCells.length > 0)
				{
					connect(selectedCells[selectedCells.length - 1], cell, "selected");
				}
				selectedCells.push(cell);
				cell.classList.toggle('selected');
				cell.dataset.letter = nextLetter;
				cell.textContent = nextLetter;
				letters[+cell.dataset.index] = nextLetter;
				//console.log(letters.join(''))

				let wlist = getCurrentWordListing();
				if (wlist.textContent.length == selectedCells.length) {
					currentListing = -1;
					//console.log("Done!");
					const newWord = [];
					selectedCells.forEach((cell) => {
						newWord.push(cell);
						cell.classList.add("used");
					});
					foundWords.push(newWord);
					//console.log(foundWords);
					clearSelected();
					for (i in newWord) {
						if (+i + 1 < newWord.length)
							connect(newWord[i], newWord[+i + 1], "used");
					}
					wlist.dataset.owner = newWord[0].dataset.index;
				}
				updateCurrentWord();
			}
		}

		function updateCurrentError() {
			const sana = document.getElementById('sana');
			sana.textContent = "";
		}

		let currentListing = -1;
		function getCurrentWordListing() {
			if (currentListing >= 0 && currentListing < wordListing.length) {
				return wordListing[currentListing];
			}
			return undefined;
		}
		function getNextLetter() {
			const unusedListings = wordListing.filter(wl => !foundWords.find(w => w[0].dataset.index === wl.dataset.owner));
			if (currentListing >= 0 && currentListing < wordListing.length) {
				if (unusedListings.includes(wordListing[currentListing])) {
					if (wordListing[currentListing].textContent.length > selectedCells.length) {
						return wordListing[currentListing].textContent[selectedCells.length];
					}
				}
				currentListing = -1;
			}
			if (unusedListings.length > 0) {
				if (unusedListings[0].textContent.length > selectedCells.length) {
					currentListing = wordListing.indexOf(unusedListings[0]);
					return unusedListings[0].textContent[selectedCells.length];
				}
			}
			currentListing = -1;
			return undefined;
		}

		function updateCurrentWord() {
			const sana = document.getElementById('sana');
			sana.textContent = "";

			const unusedListings = wordListing.filter(wl => !foundWords.find(w => w[0].dataset.index === wl.dataset.owner));
			for (let i = 0; i < wordListing.length; i++) {
				const wlist = wordListing[i];
				wlist.classList.remove("used");
				wlist.classList.remove("next");
				if (unusedListings.length > 0 && wlist === unusedListings[0])
					wlist.classList.add("next");
				else if (!unusedListings.includes(wlist))
					wlist.classList.add("used");
			}

			selectedCells.forEach(cell => {
				sana.textContent += cell.dataset.letter;
			});
			if (selectedCells.length <= 0) {
				sana.textContent = countSelectedLetters() + "/" + countTotalLetters();
			}
			document.getElementById('virhe').textContent = "";
			
			copyButton.classList.remove('disabled-button')
			if (countSelectedLetters() == 30) {
				copyButton.textContent = "Kopioi-linkki";
			} else if (selectedCells.length > 0) {
				copyButton.textContent = "Peru";
			} else {
				copyButton.textContent = "Peru";
				copyButton.classList.add('disabled-button')
			}
			history.replaceState(null, "", originalUrl + "?" + generateWipLevelCode());
		}

		function countTotalLetters() {
			let count = 0;
			wordListing.forEach(wl => count += wl.textContent.length);
			return count;
		}

		function isAdjacent(cell) {
			const index = parseInt(cell.dataset.index);
			const lastIndex = selectedCells.length > 0 ? parseInt(selectedCells[selectedCells.length - 1].dataset.index) : -1;
			if (lastIndex === -1) return true;
			const w = 5;
			const h = 6;
			const rowDiff = Math.abs(Math.floor(index / w) - Math.floor(lastIndex / w));
			const colDiff = Math.abs(index % w - lastIndex % w);
			return rowDiff <= 1 && colDiff <= 1;
		}

	</script>
</body>
</html>
