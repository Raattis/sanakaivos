<!DOCTYPE html>
<html lang="fi">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Sanakaivos</title>
	<link rel="stylesheet" href="style.css">
	<script src="sanat.js"></script>
</head>
<body>
	<div class="page-center">
		<div class="column">
			<h1>Sanakaivos</h1>
			<div id="sana-container" style="position:relative;height:25px">
				<div id="sana" class="viesti"></div>
				<div id="virhe" class="viesti"></div>
				<div id="tulos" class="viesti"></div>
			</div>
			<div id="board-container">
				<div id="board" class="board"></div>
			</div>
			<div id="buttons" class="button-container"></div>
			<div id="kopioi-tulos" class="button-container hide"><button id="copyToClipboard" class='button'>Kopioi tulos</button></div>
			<div id="loydetyt_sanat" class="sana_list"></div>
		</div>
		<div class="column">
			<div id="malli-container" class="hide">
				<div id="malli" class="board-intended"></div>
			</div>
			<div id="loydetyt_malli_sanat" class="sana_list hide"></div>
		</div>
	</div>

	<script>
		const obfuscationKey = "jy2d7ukxpX1Dz04YgFaK8ChHwOW9qlr";
		function encodeLevelCode(letters, intendedWords) {
			function encode(c) {
				c = +c;
				if (c < 0 || obfuscationKey.length <= c) {
					const msg = "ERROR: Encode failed = " + c
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				}
				return obfuscationKey[c];
			}
			let levelCode = "";
			for (let i = 0; i < intendedWords.length; i += 1) {
				if (i != 0)
					levelCode += encode(obfuscationKey.length - 1);
				for (let j = 0; j < intendedWords[i].length; j += 1) {
					levelCode += encode(intendedWords[i][j]);
				}
			}
			levelCode.length -= 1;
			const a = +('A'.charCodeAt(0));
			for (let i = 0; i < letters.length; i += 1) {
				levelCode += encode(letters[i].charCodeAt(0) - a);
			}
			return levelCode;
		}

		const generatedLevelCode = encodeLevelCode([
			'E', 'O', 'O', 'R', 'T',
			'L', 'M', 'S', 'I', 'T',
			'T', 'E', 'T', 'E', 'A',
			'I', 'T', 'R', 'A', 'G',
			'I', 'P', 'M', 'E', 'N',
			'R', 'I', 'A', 'K', 'A'
		], [
			[ 1,  6,  0,  5, 11, 10, 16, 15],
			[21, 25, 20, 26, 22, 27],
			[28, 29, 24, 19, 23, 17, 12, 18, 14],
			[ 3,  2,  7, 13,  9,  4,  8],
		]);

		let givenLevelCode = "ykjuD1gYrCO8Wh9rqlwKHFza4rd2x0X7p744FKDzapKK7K7jpKFjkpYz70Fpj1j";
		const url = window.location.href.split('?');
		if (url.length == 2) {
			givenLevelCode = url[1];
		}

		if (generatedLevelCode !== givenLevelCode) {
			console.log("Given and calculated level codes don't match. New=" + generatedLevelCode + ", Given=" + givenLevelCode);
		}

		const letters = [];
		const intendedWords = [];
		function decodeLevelCode(levelCode, letters, intendedWords) {
			function decode(c) {
				if (!obfuscationKey.includes(c)) {
					const msg = "ERROR: Decode failed = " + c
					console.log(msg);
					document.getElementById('virhe').textContent = msg;
				}
				return obfuscationKey.indexOf(c);
			}

			letters.splice(0, letters.length);
			intendedWords.splice(0, intendedWords.length);
			intendedWords.push([]);
			let intendedLetterCount = 0;
			let i = 0;
			const mayContainIntendedWords = levelCode.length >= 62 && levelCode.includes(obfuscationKey[obfuscationKey.length - 1]);
			for (; intendedLetterCount < 30 && i < levelCode.length && mayContainIntendedWords; ++i) {
				const c = decode(levelCode[+i]);
				if (c == obfuscationKey.length - 1) {
					intendedWords.push([]);
					continue;
				}
				if (intendedWords[intendedWords.length - 1].length >= 10) {
					console.log("Intended word is too long. Assuming the url only has the letters.");
					i = 0;
					intendedWords.splice(0, intendedWords.length);
					break;
				}
				intendedWords[intendedWords.length - 1].push(c);
				intendedLetterCount += 1;
			}
			
			const a = +('A'.charCodeAt(0));
			for (; letters.length < 30 && i < levelCode.length; ++i) {
				const charCode = decode(levelCode[+i]);
				let str = undefined;
				if (charCode == 26)
					str = 'Å';
				else if (charCode == 27)
					str = 'Ä';
				else if (charCode == 28)
					str = 'Ö';
				else
					str = String.fromCharCode(a + charCode)
				letters.push(str);
			}
		}
		decodeLevelCode(givenLevelCode, letters, intendedWords);

		let intendedLetterCount = 0;
		intendedWords.forEach(arr => intendedLetterCount += arr.length);
		if (intendedLetterCount == 0) {
			const msg = "Mallivastaus puuttuu. Kaivos voi olla mahdoton.";
			console.log(msg);
			document.getElementById('virhe').textContent = msg;
		} else if (intendedLetterCount != letters.length) {
			const msg = "Mallivastauksessa väärä määrä kirjaimia: " + intendedLetterCount + ", kun pitäsi olla " + letters.length + ".";
			console.log(msg);
			document.getElementById('virhe').textContent = msg;
		}

		const allCells = [];
		const selectedCells = [];
		const foundWords = [];
		const wordListing = [];

		function makeCells(resultCells, parentElement, interactive) {
			letters.forEach((letter, index) => {
				const cellWrapper = document.createElement('div');
				cellWrapper.classList.add('cell-wrapper');
				parentElement.appendChild(cellWrapper);

				const cell = document.createElement('div');
				cellWrapper.appendChild(cell);

				cell.textContent = letter;
				cell.classList.add('cell');
				cell.dataset.index = index;
				cell.dataset.letter = letter;
				resultCells.push(cell);
				if (!interactive) {
					cellWrapper.classList.add('non-interactive');
					return;
				}

				cellWrapper.addEventListener('click', () => {
					const selectedIndex = selectedCells.indexOf(cell);
					if (selectedIndex > -1 && selectedIndex + 1 == selectedCells.length) {
						toggleSelection(cell);
						return;
					}
					if (selectedIndex > -1) {
						//clearSelected()
						return;
					}

					for (i in foundWords) {
						if (foundWords[i].includes(cell)) {
							removeWord(foundWords[i]);
							return;
						}
					}

					for (word in foundWords)
					{
						if (!word.includes(cell)) continue;
						removeWord(word);
						return;
					}

					if (isAdjacent(cell)) {
						toggleSelection(cell);
					}
				});
			});
		}
		makeCells(allCells, document.getElementById('board'), true);

		const connectors = [];

		function disconnect(cell1, cell2) {
				if (!cell1 || !cell2) return;

				const rect1 = cell1.dataset.index < cell2.dataset.index ? cell1 : cell2;
				const rect2 = cell1.dataset.index < cell2.dataset.index ? cell2 : cell1;
				const key = rect1.dataset.index + "-" + rect2.dataset.index;
				const line = connectors.find(l => l.dataset.key === key);
				if (line) {
					let index = connectors.indexOf(line);
					connectors.splice(index, 1);
					line.remove();
				}
		};

		function connect(cell1, cell2, style) {
			connectImpl(document.getElementById('board-container'), cell1, cell2, style);
		}

		function connectMalli(cell1, cell2, style) {
			connectImpl(document.getElementById('malli-container'), cell1, cell2, style);
		}

		function connectImpl(containter, cell1, cell2, style) {
				disconnect(cell1, cell2);
				const line = document.createElement('div');
				containter.appendChild(line);
				line.classList.add('line');
				line.classList.add(style);
				const rect1 = cell1.dataset.index < cell2.dataset.index ? cell1 : cell2;
				const rect2 = cell1.dataset.index < cell2.dataset.index ? cell2 : cell1;
				const key = rect1.dataset.index + "-" + rect2.dataset.index;
				line.dataset.key = key;

				const x1 = rect1.offsetLeft + rect1.offsetWidth * 0.5;
				const y1 = rect1.offsetTop + rect1.offsetHeight * 0.5;
				const x2 = rect2.offsetLeft + rect2.offsetWidth * 0.5;
				const y2 = rect2.offsetTop + rect2.offsetHeight * 0.5;
				const diagonality = (x1 != x2 && y1 != y2) ? Math.pow(2, 0.5) : 1.0;
				const w = 45 * diagonality;
				const h = 10;
				const ox = x1 == x2 ? 0 : x1 < x2 ? 0 : -0;
				const oy = y1 == y2 ? 0 : y1 < y2 ? 0 : -0;
				const cx = (x1 + x2) * 0.5;
				const cy = (y1 + y2) * 0.5;
				const angle = Math.atan2(y2 - y1, x2 - x1);
				line.style.position = 'absolute';
				line.style.top = `${cy + oy - h*0.5}px`;
				line.style.left = `${cx + ox - w*0.5}px`;
				line.style.transform = `rotate(${angle}rad)`;
				line.style.width = `${w}px`;
				line.style.zIndex = -1;
				//console.log(rect1, rect2, line)
				connectors.push(line);
				return line;
		};

		connectors.splice(0, connectors.length);

		const theButtons = [];

		function makeButton(text, callback) {
			const button = document.createElement('div');
			button.textContent = text;
			button.classList.add('button');

			button.addEventListener('click', callback);
			theButtons.push(button);
			document.getElementById('buttons').appendChild(button);
			return button;
		}

		const shareableUrl = window.location.href; // Lol, this is a user string
		function disableButtons() {
			document.getElementById('buttons').classList.add('hide');
			theButtons.forEach(button => button.classList.add('disabled-button'));
			allCells.forEach(cell => cell.classList.add('disabled'));
			
			const copyContainer = document.getElementById('kopioi-tulos');
			copyContainer.classList.remove('hide');
			const copyButton = document.getElementById('copyToClipboard');
			copyButton.addEventListener('click', ()=>{
				let msg = "";
				if (youWon)
					msg += "Pääsin Sanakaivoksen läpi ajassa ";
				else
					msg += "Luovutin Sanakaivoksen ajassa ";
				msg += getResultTime() + "\nKokeile itse osoitteessa\n" + shareableUrl;
				console.log("Copied to clipboard: " + msg);
				navigator.clipboard.writeText(msg);
				copyButton.textContent = "Kopioitu!";
			});
		}

		function removeWord(word) {
			word.forEach((cell) => { cell.classList.remove('used'); });
			for (i in word)
			{
				if (+i + 1 < word.length)
					disconnect(word[i], word[+i + 1]);
			}
			const index = foundWords.indexOf(word);
			foundWords.splice(index, 1);
			for (i in wordListing) {
				if (wordListing[i].dataset.owner == word[0].dataset.index) {
					wordListing.splice(i, 1)[0].remove();
				}
			}
		}

		function gameOver() {
			clearSelected();
			if (endTime) return;
			disableButtons();
			showSolution();
			showMalli();
			getResultTime();
		}

		makeButton('luovuta', () => {
			gameOver();
			if (foundWords.length != 1)
				document.getElementById('tulos').textContent = 'Löysit ' + foundWords.length + ' sanaa ajassa ' + getResultTime();
			else
				document.getElementById('tulos').textContent = 'Löysit ' + foundWords.length + ' sanan ajassa ' + getResultTime();
		}).classList.add('luovuta');

		let revealedClues = 0;
		const vihje = makeButton('vihje', () => {
			if (revealedClues < intendedWords.length) {
				const vihjeI = intendedWords[revealedClues][0];
				allCells[vihjeI].classList.add('vihje');
				revealedClues += 1;
			}
			if (revealedClues >= intendedWords.length)
				vihje.classList.add('disabled-button');
		});
		vihje.classList.add('vihje');
		if (intendedWords.length == 0)
			vihje.classList.add('disabled-button');

		makeButton('yhdistä', () => {
			if (!isAcceptableWord(selectedCells))
			{
				clearSelected();
				updateCurrentError();
				return;
			}

			const newWord = [];
			selectedCells.forEach((cell) => {
				newWord.push(cell);
				cell.classList.add("used");
			});
			foundWords.push(newWord);
			clearSelected();

			for (i in newWord) {
				if (+i + 1 < newWord.length)
					connect(newWord[i], newWord[+i + 1], "used");
			}

			const wlist = document.createElement('div');
			wordListing.push(wlist);
			wlist.textContent = "";
			wlist.dataset.owner = newWord[0].dataset.index;
			wlist.classList.add("loydetty_sana");
			for (i in newWord)
				wlist.textContent += newWord[i].dataset.letter;
			document.getElementById('loydetyt_sanat').appendChild(wlist);
			updateCurrentWord();

			let foundCount = 0;
			foundWords.forEach(word => foundCount += word.length);
			if (foundCount == allCells.length)
				victory();
		}).classList.add('yhdista');

		function paintWordsToCells(cells, words, wordListHolder, container) {
			let prevI = -1;
			let first = true;
			cells.forEach(cell => cell.classList.add('intended'));
			words.forEach(arr => { prevI = -1;
				arr.forEach(index =>  {
					if (first)
						cells[index].classList.add("selected");
					if (prevI != -1) {
						const a = cells[prevI];
						const b = cells[index];
						const clss = first ? "intended-first" : "intended";
						setTimeout(() => { connectImpl(container, a, b, clss); }, 0); // Delay because otherwise these will be misaligned for some reason
					}
					prevI = index;
				});
				first = false;
				setTimeout(() => { connectors.splice(0, connectors.length); }); // Avoid removing connectors
				if (!wordListHolder)
					return;

				const wlist = document.createElement('div');
				wordListing.push(wlist);
				wlist.textContent = "";
				wlist.classList.add("loydetty_sana");
				arr.forEach(index => { wlist.textContent += cells[index].dataset.letter; });
				wordListHolder.appendChild(wlist);
			});
		}

		function showSolution() {
			const board = document.getElementById('board');
			board.replaceChildren();
			connectors.splice(0,connectors.length).forEach(connector => connector.remove());

			const gameOverCells = [];
			makeCells(gameOverCells, board, false);
			paintWordsToCells(gameOverCells, foundWords.map(arr => arr.map(cell => +cell.dataset.index)), undefined, document.getElementById('board-container'));
		}

		function showMalli() {
			updateCurrentWord();
			if (intendedWords.length == 0)
				return;
			document.getElementById('malli-container').classList.remove('hide');
			document.getElementById('loydetyt_malli_sanat').classList.remove('hide');

			const intendedSoluctionCells = [];
			makeCells(intendedSoluctionCells, document.getElementById('malli'), false);
			paintWordsToCells(intendedSoluctionCells, intendedWords, document.getElementById('loydetyt_malli_sanat'), document.getElementById('malli-container'));
		}

		const startTime = new Date();
		let endTime = null;
		function getResultTime() {
			if (!endTime) endTime = new Date();
			const duration = +Math.floor((endTime - startTime) / 1000);
			const hours = Math.floor((duration / 60 / 60));
			const minutes = Math.floor((duration / 60) % 60);
			const seconds = Math.floor(duration % 60);
			if (hours > 0)
				return `${hours}:${minutes}:${seconds}`;
			else if (minutes > 0)
				return `${minutes}:${seconds}`;
			else
				return `${seconds} sekuntia`;
		}

		let youWon = false;
		function victory() {
			youWon = true;
			gameOver();
			document.getElementById('tulos').textContent = 'Löysit kaikki sanat ajassa ' + getResultTime();
		}

		function clearSelected() {
			selectedCells.forEach((cell) => {
				cell.classList.remove('selected');
			});
			for (i in selectedCells)
			{
				if (+i + 1 < selectedCells.length)
					disconnect(selectedCells[i], selectedCells[+i + 1]);
			}
			selectedCells.length = 0;
		}

		function isAcceptableWord(cells) {

			document.getElementById('virhe').textContent = "";

			if (cells.length < 3 || cells.length > 10)
				return false;

			let word = "";
			for (i in cells) {
				word += cells[i].dataset.letter;
			}
			if (validWords.includes(word)) {
				return true;
			}

			document.getElementById('virhe').textContent = word + " ei kelpaa";

			return false;
		}

		function popSelection() {
			const index = selectedCells.length - 1;
			if (index <= -1)
			{
				console.log("Trying to unselect non-selected cell.");
				return;
			}

			const cell = selectedCells.splice(index, 1)[0];
			cell.classList.remove('selected');
			if (index > 0)
				disconnect(selectedCells[index - 1], cell);
		}

		function toggleSelection(cell) {
			const index = selectedCells.indexOf(cell);
			if (index > -1 && selectedCells.length == index + 1) {
				if (selectedCells.length == 1) { clearSelected(); }
				else { popSelection(); }
			} else {
				if (selectedCells.length >= 10)
					return;

				if (selectedCells.length > 0)
				{
					connect(selectedCells[selectedCells.length - 1], cell, "selected");
				}
				selectedCells.push(cell);
				cell.classList.toggle('selected');
			}
			updateCurrentWord();
		}

		function updateCurrentError() {
			const sana = document.getElementById('sana');
			sana.textContent = "";
		}

		function updateCurrentWord() {
			const sana = document.getElementById('sana');
			sana.textContent = "";
			selectedCells.forEach(cell => {
				sana.textContent += cell.dataset.letter;
			});
			document.getElementById('virhe').textContent = "";
		}

		function isAdjacent(cell) {
			const index = parseInt(cell.dataset.index);
			const lastIndex = selectedCells.length > 0 ? parseInt(selectedCells[selectedCells.length - 1].dataset.index) : -1;
			if (lastIndex === -1) return true;
			const w = 5;
			const h = 6;
			const rowDiff = Math.abs(Math.floor(index / w) - Math.floor(lastIndex / w));
			const colDiff = Math.abs(index % w - lastIndex % w);
			return rowDiff <= 1 && colDiff <= 1;
		}
	</script>
</body>
</html>
